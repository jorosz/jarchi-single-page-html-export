// Updated Generate Single-page HTML Export
// Copyright (c) 2026 J Orosz
// Original Version Copyright (c) 2020 Phillip Beauvoir & Jean-Baptiste Sarrodie
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following
// conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.

// Set this to false for jArchi 1.6.0 and below or if the Archi preference "Enable Common JS support" is off
// See https://github.com/archimatetool/archi-scripting-plugin/wiki/Using-Node.js-modules
load(__DIR__ + 'libs/nashorn-polyfills.js');

_ = require(__DIR__ + 'libs/underscore-min.js');
marked = require(__DIR__ + 'libs/marked.min.js');

console.show();
console.clear();

// Use Mustache.js-style templating
_.templateSettings = {
  interpolate: /\{\{(.+?)\}\}/g,
  evaluate: /<%([\s\S]+?)%>/g
};

// Set Markdown rendering options
var mdOptions = {
  gfm: true,
  breaks: true,
  smartLists: true,
  smartypants: true
};

var roboto = readFully(__DIR__ + 'resources/roboto.css', 'UTF-8');
var icon = readFully(__DIR__ + 'resources/icon.css', 'UTF-8');
var picnic = readFully(__DIR__ + 'resources/picnic-custom.css', 'UTF-8');

var tplMainReport = _.template(readFully(__DIR__ + 'templates/main-report.html', 'UTF-8'));
var tplVisibilityRuleBold = _.template(readFully(__DIR__ + 'templates/visibility-rule-bold.tpl', 'UTF-8'));
var tplVisibilityRuleReveal = _.template(readFully(__DIR__ + 'templates/visibility-rule-reveal.tpl', 'UTF-8'));
var tplInputCheckbox = _.template(readFully(__DIR__ + 'templates/input-checkbox.tpl', 'UTF-8'));
var tplTreeView = _.template(readFully(__DIR__ + 'templates/model-tree-view.tpl', 'UTF-8'));

var tplView = _.template(readFully(__DIR__ + 'templates/view.tpl', 'UTF-8'));

var tplFunction = _.template(readFully(__DIR__ + 'templates/function.tpl', 'UTF-8'));
var tplFunctionApp = _.template(readFully(__DIR__ + 'templates/functionapp.tpl', 'UTF-8'));
var tplRelationship = _.template(readFully(__DIR__ + 'templates/relationship.tpl', 'UTF-8'));

var visibilityRulesBold = '';
var visibilityRulesReveal = '';
var inputCheckbox = '';
var treeContent = '';
var viewCollection = []; // this list will contain all the objects representing each view

var allFolders = $('folder');
var viewsFolder = $(model).children().filter('folder.Views');
var viewFolders = viewsFolder.find('folder');
var nonViewFolders = allFolders.not(viewsFolder).not(viewFolders);
var folders = selection.filter('folder').not(nonViewFolders); // TODO: could also support views in the selection to save a single view

if (!folders.size()) {
  folders = viewsFolder;
  console.log('All views have been selected.');
}

var yyyymmdd = new Date().toISOString().slice(0, 10).replace(/-/g, '');
var filePath = window.promptSaveFile({
  title: 'Save as HTML file',
  filterExtensions: ['*.html', '*.*'],
  fileName: model.name + yyyymmdd + '.html'
});

if (!filePath) {
  console.log('User cancelled.');
  exit();
}

_.chain(folders)
  .sortBy((f) => f.name)
  .each((f) => {
    exportViews(f);
  });

// TODO: this ugly recursion with a closure should probably also be fixed at one point
function exportViews(folder) {
  console.log('Exporting "', folder.name, '"...');
  var previousContent = treeContent;
  treeContent = '';

  _.chain($(folder).children('folder'))
    .sortBy((f) => f.name)
    .each((f) => {
      exportViews(f); // does the ugly recursion to progress subfolders
    });

  // loop through the views and collect data
  let isFirst = true;
  _.chain($(folder).children('view'))
    .sortBy((v) => v.name)
    .each((v) => {
      // Tree generation for view selection
      treeContent += tplTreeView({
        viewId: 'id-' + v.id,
        viewName: _.escape(v.name)
      });
      visibilityRulesBold += tplVisibilityRuleBold({ viewId: 'id-' + v.id }); // TODO: maybe one day check if a wildcard can do?
      visibilityRulesReveal += tplVisibilityRuleReveal({
        viewId: 'id-' + v.id
      });
      inputCheckbox += tplInputCheckbox({
        viewId: 'id-' + v.id,
        checked: isFirst ? 'checked' : '' // first view is checked so that it's shown by default
      });
      isFirst = false;

      // this will store our data for the view
      let viewData = {
        name: _.escape(v.name),
        id: 'id-' + v.id,
        diagram: $.model.renderViewAsBase64(v, 'PNG'),
        documentation: marked(_.escape(v.documentation), mdOptions),
        functions: [], // will hold the list of functions (raw data)
        components: [], // will hold the data for each component
        apps_html: '', // stores rendered data for apps and functions
        flows: [],
        flows_html: ''
      };

      // Update lists of functional elements
      // need all application-functions so that we can put them into a map to be sorted by component
      // populates the list of functions in the viewData
      $(v)
        .find('application-function')
        .each(function (fun) {
          let ec = $(fun.concept);
          // determine where this function is linked to
          let appComponent = ec.inRels('realization-relationship').sourceEnds().filter('application-component').first();

          let fObj = {
            name: _.escape(fun.name),
            id: fun.id,
            applicationName: appComponent ? appComponent.name : 'N/A',
            applicationID: appComponent ? appComponent.id : 'default',
            documentation: marked(_.escape(ec.documentation), mdOptions)
          };

          viewData.functions.push(fObj);
        });

      // iterate application components and build the list
      // select all functions for each application from the previously populated list
      $(v)
        .find('application-component')
        .each((app) => {
          let aObj = {
            appName: app.name,
            appDescription: marked(_.escape(app.documentation), mdOptions),
            // next one filters functions for this application into functions
            functions: _.where(viewData.functions || [], {
              applicationID: app.id
            }),
            functions_html: ''
          };
          viewData.components.push(aObj);
        });

      // collect flow relationships
      $(v)
        .find('flow-relationship')
        .each((r) => {
          let fwObj = {
            relationshipName: _.escape(r.name),
            relationshipType: properCase(r.type),
            relationshipSource: _.escape(r.source.name),
            relationshipTarget: _.escape(r.target.name),
            relationshipDocumentationText: _.escape(r.documentation).replace(/\n/g, '<br>'),
            relationshipDocumentationMarkdown: marked(_.escape(r.documentation), mdOptions)
          };
          viewData.flows.push(fwObj);
        });

      viewCollection.push(viewData);
    }); // view loop

  treeContent = previousContent + treeContent;
} // export views function

// now we populate the html portions for each section

// loop views and populate data
_(viewCollection).each((v) => {
  // map the flows
  let flow_html = _.map(v.flows || [], (f) => {
    return tplRelationship(f) || '';
  }).join('\n');

  // map the apps
  let app_html = _.map(v.apps || [], (app) => {
    // inside the app we map the function
    app.functions_html = _.map(app.functions || [], (fun) => {
      return tplFunction(fun) || '';
    }).join('');
    return tplFunctionApp(app) || '';
  }).join('');

  v.flow_html = flow_html;
  v.app_html = app_html;
});

// apply view template to get the views html
let views_html = _(viewCollection)
  .map((v) => {
    return tplView(v) || '';
  })
  .join('');

let mainReport = tplMainReport({
  roboto: roboto,
  icon: icon,
  picnic: picnic,
  modelTitle: _.escape(model.name),
  modelPurposeText: _.escape(model.purpose).replace(/\n/g, '<br>'),
  modelPurposeMarkdown: marked(_.escape(model.purpose), mdOptions),
  visibilityRulesBold: visibilityRulesBold,
  visibilityRulesReveal: visibilityRulesReveal,
  inputCheckbox: inputCheckbox,
  treeContent: treeContent,
  views: views_html,
  sidebarBgColor: '#37474f',
  sidebarColor: '#DDDDDD',
  sidebarWidth: '350px',
  sidebarMargin: '10px',
  sidebarFooterHeight: '0px',
  headerHeight: '60px',
  headerBgColor: '#0074D9',
  headerColor: '#fff',
  mainBgColor: '#fff',
  mainColor: '#000',
  mainMargin: '20px',
  mainHeaderMargin: '35px',
  mainHeaderBgColor: '#eceff1',
  mainHeaderColor: '#546e7a',
  treeMargin: '1.3em'
});

$.fs.writeFile(filePath, mainReport, 'UTF-8');

console.log('Export terminated.');

function properCase(str) {
  return str
    .replace(/\w*/g, function (txt) {
      return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    })
    .replace('-', ' ');
}
